/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "check.h"
#include "token.h"
#include "server_data.h"

#define SIGNATURE "###"
#define LINE_MAX_SIZE 128
#define TOKEN_SIZE 16
#define NO_PERMISSIONS "∗,−"
#define USER_NOT_FOUND "USER_NOT_FOUND"
#define REQUEST_DENIED "REQUEST_DENIED"
#define PERMISSION_DENIED "PERMISSION_DENIED"
#define TOKEN_EXPIRED "TOKEN_EXPIRED"
#define RESOURCE_NOT_FOUND "RESOURCE_NOT_FOUND"
#define OPERATION_NOT_PERMITTED "OPERATION_NOT_PERMITTED"
#define PERMISSION_GRANTED "PERMISSION_GRANTED"
#define OK "OK"
#define EMPTY "EMPTY"
#define TOKEN_NOT_FOUND "TOKEN_NOT_FOUND" 

struct token_permissions {
	char token[20];
	char permissions[LINE_MAX_SIZE];
};

struct client_resource_token {
	char clientId[TOKEN_SIZE];
	char resource_access_token[TOKEN_SIZE];
};

struct token_permissions token_permissions_list[20];
struct client_resource_token client_resource_token_list[20];
char signed_tokens[20][20];
int token_permissions_index = 0;
int client_resource_token_index = 0;
int signed_tokens_index = 0;
char server_resource_access_token[TOKEN_SIZE];

char **
request_authorization_1_svc(char **argp, struct svc_req *rqstp)
{
	static char * result;
	char *clientId = argp[0]; // Assuming clientId is the first argument

	printf("BEGIN %s AUTHZ\n", clientId);

	int found = 0;
	for (int i = 0; i < id_count; i++) {
		if (strcmp(clientId, user_ids_list[i]) == 0) {
			found = 1;
			break;
		}
	}

	if (found == 0) {
		result = USER_NOT_FOUND;
	} else {
		result = generate_access_token(clientId);
		printf("  RequestToken = %s\n", result);
	}
	// Force the buffer to be flushed
    fflush(stdout);
	return &result;
}

struct request_access_token_output *
request_access_token_1_svc(struct request_access_token_input *argp, struct svc_req *rqstp)
{
	static struct request_access_token_output result;
	char *auth_token = argp->auth_token;
	char *client_id = argp->client_id;
	int refresh_duration = argp->refresh_duration;

	// check if the token was signed
	int found = 0;
	for (int i = 0; i < signed_tokens_index; i++) {
		if (strcmp(auth_token, signed_tokens[i]) == 0) {
			found = 1;
			break;
		}
	}

	// if it was signed, continue
	if (found == 1) {
		// Getting the original auth_token by getting rid of the signature
		char *auth_token_without_signature = calloc(20, sizeof(char));
		strncpy(auth_token_without_signature, auth_token, strlen(auth_token) - strlen(SIGNATURE));
		// generate the new tokens
		result.resource_access_token = generate_access_token(auth_token_without_signature);
		if (refresh_duration > 0) {
			result.refresh_token = generate_access_token(result.resource_access_token);
		}
		result.request_response = OK;
		result.refresh_token = EMPTY;
		result.duration = refresh_duration;
		printf("  AccessToken = %s\n", result.resource_access_token);
		// Save in DB: clientId - resource_access_token
		strcpy(client_resource_token_list[client_resource_token_index].clientId, client_id);
		strcpy(client_resource_token_list[client_resource_token_index].resource_access_token, result.resource_access_token);
		client_resource_token_index++;
	} else {
		result.resource_access_token = REQUEST_DENIED;
		result.duration = 0;
		result.refresh_token = REQUEST_DENIED;
		result.request_response = REQUEST_DENIED;
	}
	// Force the buffer to be flushed
    fflush(stdout);
	return &result;
}

char **
validate_delegated_action_1_svc(struct validate_delegated_action_input *argp, struct svc_req *rqstp)
{
	static char * result;
	char* operation = argp->operation;
	char* resource = argp->resource;
	char* resource_access_token = argp->resource_access_token;
	
	// struct token_permissions {
	// 	char token[20];
	// 	char permissions[LINE_MAX_SIZE];
	// };
	// struct client_resource_token {
	// 	char clientId[TOKEN_SIZE];
	// 	char resource_access_token[TOKEN_SIZE];
	// };
	// struct token_permissions token_permissions_list[20];
	// struct client_resource_token client_resource_token_list[20];

	// Searching for the token
	int token_found = 0;
	int token_index = -1;
	for (int i = 0; i < client_resource_token_index; i++) {
		if (strstr(client_resource_token_list[i].resource_access_token, resource_access_token) != NULL) {
			token_found = 1;
			token_index = i;
			break;
		}
	}
	if (token_found == 0) {
		result = TOKEN_NOT_FOUND;
		// Force the buffer to be flushed
    	fflush(stdout);
		return &result;
	}

	// Verify if the resource_token is associated with the clientId
	if (strstr(client_resource_token_list[token_index].clientId, client_id) == NULL) {
		result = PERMISSION_DENIED;
		// Force the buffer to be flushed
    	fflush(stdout);
		return &result;
	}


	// Searching for the resource wanted on the server DB
	int resource_found = 0;
	for (int i = 0; i < resources_count; i++) {
		if (strcmp(resource, resources_list[i]) == 0) {
			resource_found = 1;
			break;
		}
	}
	if (resource_found == 0) {
		result = RESOURCE_NOT_FOUND;
		// Force the buffer to be flushed
    	fflush(stdout);
		return &result;
	}

	// Searching for permissions for the operation
	if (strstr(operation, token_permissions_list[token_index].permissions) == NULL) {
		result = OPERATION_NOT_PERMITTED;
		// Force the buffer to be flushed
    	fflush(stdout);
		return &result;
	}



	result = PERMISSION_GRANTED;
	// Force the buffer to be flushed
    fflush(stdout);
	return &result;
}

char **
approve_request_token_1_svc(char **argp, struct svc_req *rqstp)
{
	static char * result;
	char *token = argp[0];

	// Read line from approvals.db
    char line[LINE_MAX_SIZE];
	fgets(line, sizeof(line), file3);
	if (strstr(line, "*,-") != NULL) {
		result = token;
	} else {
		//add permissions to the token
		strcpy(token_permissions_list[token_permissions_index].token, token);
		strcpy(token_permissions_list[token_permissions_index].permissions, line);
		token_permissions_index++;
		// sign the token
		result = strcat(token, SIGNATURE);
		strcpy(signed_tokens[signed_tokens_index], result);
		signed_tokens_index++;
	}
	// Force the buffer to be flushed
    fflush(stdout);
	return &result;
}