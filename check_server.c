/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "check.h"
#include "token.h"
#include "server_data.h"

#define SIGNATURE "###"
#define LINE_MAX_SIZE 128
#define TOKEN_SIZE 16
#define NO_PERMISSIONS "∗,−"
#define USER_NOT_FOUND "USER_NOT_FOUND"
#define REQUEST_DENIED "REQUEST_DENIED"
#define PERMISSION_DENIED "PERMISSION_DENIED"
#define TOKEN_EXPIRED "TOKEN_EXPIRED"
#define RESOURCE_NOT_FOUND "RESOURCE_NOT_FOUND"
#define OPERATION_NOT_PERMITTED "OPERATION_NOT_PERMITTED"
#define PERMISSION_GRANTED "PERMISSION_GRANTED"
#define OK "OK"
#define EMPTY "EMPTY"
#define TOKEN_NOT_FOUND "TOKEN_NOT_FOUND"
#define DELIMITER ","
#define READ "READ"
#define MODIFY "MODIFY"
#define DELETE "DELETE"
#define EXECUTE "EXECUTE"
#define INSERT "INSERT"

struct token_permissions
{
	char token[20];
	char permissions[LINE_MAX_SIZE];
};

struct client_resource_token
{
	char clientId[TOKEN_SIZE];
	char resource_access_token[TOKEN_SIZE];
	char refresh_token[TOKEN_SIZE];
	int token_duration;
};

struct token_permissions token_permissions_list[20];
struct client_resource_token client_resource_token_list[20];
char signed_tokens[20][20];
int token_permissions_index = 0;
int client_resource_token_index = 0;
int signed_tokens_index = 0;
char server_resource_access_token[TOKEN_SIZE];

char **
request_authorization_1_svc(char **argp, struct svc_req *rqstp)
{
	static char *result;
	char *clientId = argp[0]; // Assuming clientId is the first argument

	printf("BEGIN %s AUTHZ\n", clientId);

	int found = 0;
	for (int i = 0; i < id_count; i++)
	{
		if (strcmp(clientId, user_ids_list[i]) == 0)
		{
			found = 1;
			break;
		}
	}

	if (found == 0)
	{
		result = USER_NOT_FOUND;
	}
	else
	{
		result = generate_access_token(clientId);
		printf("  RequestToken = %s\n", result);
	}
	// Force the buffer to be flushed
	fflush(stdout);
	return &result;
}

struct request_access_token_output *
request_access_token_1_svc(struct request_access_token_input *argp, struct svc_req *rqstp)
{
	static struct request_access_token_output result;
	char *auth_token = argp->auth_token;
	char *client_id = argp->client_id;
	int refresh_duration = argp->refresh_duration;

	// check if the token was signed
	int found = 0;
	for (int i = 0; i < signed_tokens_index; i++)
	{
		if (strcmp(auth_token, signed_tokens[i]) == 0)
		{
			found = 1;
			break;
		}
	}

	// if it was signed, continue
	if (found == 1)
	{
		// Getting the original auth_token by getting rid of the signature
		char *auth_token_without_signature = calloc(20, sizeof(char));
		strncpy(auth_token_without_signature, auth_token, strlen(auth_token) - strlen(SIGNATURE));
		// generate the new tokens
		result.resource_access_token = generate_access_token(auth_token_without_signature);
		printf("  AccessToken = %s\n", result.resource_access_token);
		if (refresh_duration > 0)
		{
			result.refresh_token = generate_access_token(result.resource_access_token);
			strcpy(client_resource_token_list[client_resource_token_index].refresh_token, result.refresh_token);
			printf("  RefreshToken = %s\n", result.refresh_token);
		}
		result.request_response = OK;
		result.refresh_token = EMPTY;
		result.duration = refresh_duration;
		// Save in DB: clientId - resource_access_token
		strcpy(client_resource_token_list[client_resource_token_index].clientId, client_id);
		strcpy(client_resource_token_list[client_resource_token_index].resource_access_token, result.resource_access_token);
		client_resource_token_list[client_resource_token_index].token_duration = token_valability; // number of available operations per token
		client_resource_token_index++;
	}
	else
	{
		result.resource_access_token = REQUEST_DENIED;
		result.duration = 0;
		result.refresh_token = REQUEST_DENIED;
		result.request_response = REQUEST_DENIED;
	}
	// Force the buffer to be flushed
	fflush(stdout);
	return &result;
}

struct validate_delegated_action_output *
validate_delegated_action_1_svc(struct validate_delegated_action_input *argp, struct svc_req *rqstp)
{
	static struct validate_delegated_action_output result;
	char *client_id = argp->client_id;
	char *operation = argp->operation;
	char *resource = argp->resource;
	char *resource_access_token = argp->resource_access_token;
	char operation_alias[20];

	// Format resource in order to get rid of potential '\n' at the end of it
	if (resource[strlen(resource)] == '\n') {
		resource[strlen(resource)] = '\0';
	}
	if (resource[strlen(resource) - 1] == '\n') {
		resource[strlen(resource) - 1] = '\0';
	}

	if (strcmp(operation, "R") == 0)
	{
		strcpy(operation_alias, READ);
	}
	else if (strcmp(operation, "M") == 0)
	{
		strcpy(operation_alias, MODIFY);
	}
	else if (strcmp(operation, "D") == 0)
	{
		strcpy(operation_alias, DELETE);
	}
	else if (strcmp(operation, "X") == 0)
	{
		strcpy(operation_alias, EXECUTE);
	}
	else if (strcmp(operation, "I") == 0)
	{
		strcpy(operation_alias, INSERT);
	}

	//printf("CLIENT=|%s| AND TOKEN=|%s|\n", client_id, resource_access_token);

	// Searching for the token
	int token_found = 0;
	int token_index = -1;
	for (int i = 0; i < client_resource_token_index; i++)
	{
		if (strstr(client_resource_token_list[i].resource_access_token, resource_access_token) != NULL)
		{
			token_found = 1;
			token_index = i;
			break;
		}
	}
	if (token_found == 0)
	{
		result.request_response = PERMISSION_DENIED;
		result.regenerated_resource_access_token = "";
		printf("DENY (%s,%s,%s,%d)\n", operation_alias, resource, client_resource_token_list[token_index].resource_access_token, 0);
		// Force the buffer to be flushed
		fflush(stdout);
		return &result;
	}
	// Verify if the resource_token is associated with the clientId
	if (strstr(client_resource_token_list[token_index].clientId, client_id) == NULL)
	{
		result.request_response = PERMISSION_DENIED;
		result.regenerated_resource_access_token = "";
		printf("DENY (%s,%s,%s,%d)\n", operation_alias, resource, client_resource_token_list[token_index].resource_access_token, 0);
		// Force the buffer to be flushed
		fflush(stdout);
		return &result;
	}

	// Verify if the resource_token_expired
	if (client_resource_token_list[token_index].token_duration <= 0)
	{
		// if the client doesnt have a refresh_token, we can't regenerate it
		if (strcmp(client_resource_token_list[token_index].refresh_token, EMPTY) == 0 ||
			strcmp(client_resource_token_list[token_index].refresh_token, "") == 0)
		{
			result.request_response = TOKEN_EXPIRED;
			result.regenerated_resource_access_token = "";
			printf("DENY (%s,%s,,%d)\n", operation_alias, resource, 0);
			// Force the buffer to be flushed
			fflush(stdout);
			return &result;
		}
		// if he has a refresh_token, we use it and regenerate the token valability
		strcpy(client_resource_token_list[token_index].resource_access_token, 
			generate_access_token(client_resource_token_list[token_index].refresh_token));
		strcpy(client_resource_token_list[token_index].refresh_token, 
			generate_access_token(client_resource_token_list[token_index].resource_access_token));
		client_resource_token_list[token_index].token_duration = token_valability;
		result.regenerated_resource_access_token = client_resource_token_list[token_index].resource_access_token;

		printf("BEGIN %s AUTHZ REFRESH\n", client_resource_token_list[token_index].clientId);
		printf("  AccessToken = %s\n", client_resource_token_list[token_index].resource_access_token);
		printf("  RefreshToken = %s\n", client_resource_token_list[token_index].refresh_token);
	}

	// Searching for the resource wanted on the server DB
	int resource_found = 0;
	for (int i = 0; i < resources_count; i++)
	{
		if (strstr(resource, resources_list[i]) != NULL ||
			strstr(resources_list[i], resource) != NULL)
		{
			resource_found = 1;
			break;
		}
	}
	if (resource_found == 0)
	{
		result.request_response = RESOURCE_NOT_FOUND;
		result.regenerated_resource_access_token = "";
		// Decrease the token's duration after doing the operation
		client_resource_token_list[token_index].token_duration--;
		printf("DENY (%s,%s,%s,%d)\n", operation_alias, resource, client_resource_token_list[token_index].resource_access_token, client_resource_token_list[token_index].token_duration);
		// Force the buffer to be flushed
		fflush(stdout);
		return &result;
	}

	// Searching for permissions for the operation
	int found_permission = 0;
	int found_resource = 0;
	char line[256]; // Adjust the size as needed
	// Copy the Permissions string to a temporary buffer
	strncpy(line, token_permissions_list[token_index].permissions, sizeof(line));
	line[sizeof(line) - 1] = '\0';
	char *token = strtok(line, DELIMITER);
	while (token != NULL)
	{
		// Reading resource
		if (strstr(token, resource) != NULL || strstr(resource, token) != NULL)
		{
			found_resource = 1;
		}
		token = strtok(NULL, DELIMITER);
		// Reading permission on the resource
		if (found_resource == 1)
		{
			if (strstr(operation, token) != NULL || strstr(token, operation) != NULL)
			{
				found_permission = 1;
			}
			break;
		}
		token = strtok(NULL, DELIMITER);
	}

	if (found_permission == 0)
	{
		result.request_response = OPERATION_NOT_PERMITTED;
		result.regenerated_resource_access_token = "";
		// Decrease the token's duration after doing the operation
		client_resource_token_list[token_index].token_duration--;
		printf("DENY (%s,%s,%s,%d)\n", operation_alias, resource, client_resource_token_list[token_index].resource_access_token, client_resource_token_list[token_index].token_duration);
		// Force the buffer to be flushed
		fflush(stdout);
		return &result;
	}

	result.request_response = PERMISSION_GRANTED;
	result.regenerated_resource_access_token = "";
	// Decrease the token's duration after doing the operation
	client_resource_token_list[token_index].token_duration--;
	printf("PERMIT (%s,%s,%s,%d)\n", operation_alias, resource, client_resource_token_list[token_index].resource_access_token, client_resource_token_list[token_index].token_duration);
	// Force the buffer to be flushed
	fflush(stdout);
	return &result;
}

char **
approve_request_token_1_svc(char **argp, struct svc_req *rqstp)
{
	static char *result;
	char *token = argp[0];

	// Read line from approvals.db
	char line[LINE_MAX_SIZE];
	fgets(line, sizeof(line), file3);
	if (strstr(line, "*,-") != NULL)
	{
		result = token;
	}
	else
	{
		// add permissions to the token
		strcpy(token_permissions_list[token_permissions_index].token, token);
		strcpy(token_permissions_list[token_permissions_index].permissions, line);
		token_permissions_index++;
		// sign the token
		result = strcat(token, SIGNATURE);
		strcpy(signed_tokens[signed_tokens_index], result);
		signed_tokens_index++;
	}
	// Force the buffer to be flushed
	fflush(stdout);
	return &result;
}